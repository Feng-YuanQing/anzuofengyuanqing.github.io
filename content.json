{"meta":{"title":"风远清的博客","subtitle":"博观而约取,厚积而薄发","description":"致于个人学习研讨","author":"Yuanqing Feng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"初识计算机视觉","slug":"初识计算机视觉","date":"2019-02-21T15:33:37.219Z","updated":"2019-02-22T15:16:47.240Z","comments":true,"path":"2019/02/21/初识计算机视觉/","link":"","permalink":"http://yoursite.com/2019/02/21/初识计算机视觉/","excerpt":"","text":"实验室第一次培训所得 一.概述—————————————————————— 1.什么是计算机视觉？ 简单来说，计算机视觉是一门研究如何使机器“看”的科学,让计算机去认知世界，是从图像或者多维数据中获取‘信息’的人工智能系统。会涉及图像处理 + 机器学习 + 三维理论 。 2.至于用途么，显然极其广。 比如： 图像识别（之前比较热门，ImageNet） 无人汽车 人脸识别 AR，VR 三维重建 工程测绘 图像分割……. 3.计算机图形学、数字图像处理、计算机视觉之间的区别与联系。 在网上曾看到一种不确切的描述： 计算机图形学≈画图 计算机视觉≈看图 数字图像处理≈看图前各种准备 4.相关配置 OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库,最初是Inter公司开发核心库使用C/C++编写，支持CUDA加速。现在已经发展到了OpenCV4.0.1版本,基本全平台。OpenCV下载网址https://opencv.org/releases.html教程网址https://blog.csdn.net/weixin_37800680/article/details/70991173 二.理论——————————————————————— 1.图像图像可以看成什么： 可以采用取样定理（奈奎斯特定理 Nyquist’s Theorem : 一维数字信号f(t)的频率为𝝎，采样信号f(i,t)频率大于𝟐𝝎，可以根据采样恢复信号）将图像转化为数字信号。 如上图，按一定的比例对图像进行离散化处理，离散化后像素值用一个字节byte (8bit)表示。在进行离散化处理时，先进行取样，取样的精细程度不同，对图像的处理后的效果也不同。看下图： //注意上传时将此图传至github上 此外，图像可以理解为由一组波组成，该波函数具体表示为傅里叶级数（𝑓(𝑥)= 1/2 𝑎0+∑(𝑘=1)^𝑛〖(𝑎𝑘 cos⁡(𝑘𝑥)+𝑏𝑘 sin⁡(𝑘𝑥))〗）。其本质是将一个周期的信号分解成无限多分开的（离散的）正弦波。 2.图像滤波图像去噪是指减少数字图像中噪声的过程称为图像去噪。现实中的数字图像在数字化和传输过程中常受到成像设备与外部环境噪声干扰等影响，称为含噪图像或噪声图像。 图像滤波，百度百科中解释，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。(个人理解是对图像去噪的处理) 对于数字图像信号，噪声表现为或大或小的极值，这些极值通过加减作用于图像象素的真实灰度值上，在图像造成亮、暗点干扰，极大降低了图像质量，影响图像复原、分割、特征提取、图识别等后继工作的进行。因此，去噪时基本原理是对图像信号函数进行求导。 求导相关知识：//注意上传时将此图传至github上 (1)图像求导： 1&gt;使用有限差分表示图像的导数或者偏导数//注意上传时将此图传至github上 2&gt;矩阵求导：雅可比矩阵，海森矩阵 (2)卷积： 卷积可以看作是一种结合了矩阵运算的计算方法:𝑥(𝑡)∗𝑦(𝑡)=∫_(−∞)^(+∞)▒𝑥(𝜏)𝑦(𝑡−𝜏)𝑑𝜏 现附一张经典的卷积原理图：//注意上传时将此图传至github上 具体解释：.这是一图像取样后的信号矩阵 //注意上传时将此图传至github上 选取一卷积核（滤波器）//注意上传时将此图传至github上 卷积运算 //注意上传时将此图传至github上 运算过程： 卷积核按照从左到右，从上到下的顺序遍历原取样信号66矩阵，得到44矩阵（易知在遍历时，得到的结果矩阵会消失掉周围一圈数据） 最终结果 //注意上传时将此图传至github上 (3)高斯模糊 可以理解为图像中的每个像素都重新设置像素值为周边相邻像素的平均值。离当前像素距离最近的像素与其联系越密切，应该使用加权平均。相邻像素的范围越广，模糊程度越大。 //注意上传时将此图传至github上 三.实战———————————————————————以下代码公用：12345---------#include&lt;opencv2/opencv.hpp&gt;using namespace std;using namespace cv; 1&gt;.摄像头的简单使用123456789101112131415161718192021222324-------------------int main(int argc,char ** argv)&#123; //调用摄像头 VideoCapture video(0); while (true) &#123; //Mat矩阵缩写,基础图像处理容器,定义了一个frame对象来存图片的数据 Mat frame;//视频的帧 video &gt;&gt; frame;//写入每一帧 cvtColor(frame, frame,COLOR_RGB2GRAY ); //颜色空间的转换:第一个参数是输入图像，第二个是输出，第三个转换类型(灰度) namedWindow(\"frame\", WINDOW_AUTOSIZE); //创建frame的窗口，第二个参数表示自适应图片大小 imshow(\"frame\", frame);//展示图片 /*注释 参数1：显示图片的窗口名称。 参数2：储存图片数据的对象。 */ waitKey(30);//每30毫秒刷新一次帧 &#125; return 0;&#125; 2&gt;.使用 1 * 3 的卷积核处理图像(差分)123456789101112131415161718192021222324252627282930313233-------------------Mat src = imread(\"E:/opencv_source/opencv_phsource/lena.jpg\", 1);/*注释 上面的Mat我们可以理解为一个存储数据的容器，定义了一个src对象来存图片的数据。 imread参数1：引号里面的为图片路径，直接在电脑路径复制。这里注意复制出来后是右斜杠\"\\\"，我们程序要左斜杠。 imread参数2：如果写为1最后输出就显示原图，如果写为0，最后输出就显示灰度图。*/ cvtColor(src, src, COLOR_BGR2GRAY);//将图像转化为灰度图像namedWindow(\"src\", WINDOW_AUTOSIZE);//创建src的窗口，第二个参数表示自适应图片大小imshow(\"src\", src);//展示图片 Mat dImg = Mat(src.rows, src.cols - 2, CV_8UC1);///新建一个矩阵,用以存放改动之后的矩阵值./*注释对于二维的和多通道的图像，我们首先定义它们的大小：按行和列计数。CV_ [每一项的位数] [有符号或无符号] [类型前缀] C [通道数]CV_8UC1 意味着我们使用那些长的 8 位无符号的 char 类型和每个像素都有一个项目的这一个通道的形成。*///遍历图像for (int i = 0; i &lt; src.rows; i++)&#123; for (int j = 1; j &lt; src.cols - 1; j++) &#123; dImg.at&lt;uchar&gt;(i, j - 1) = src.at&lt;uchar&gt;(i, j + 1) -src.at&lt;uchar&gt;(i, j - 1); //差分 /*注释 在使用该卷积核遍历时，遍历后的矩阵比原矩阵少两列 */ &#125;&#125;namedWindow(\"dst\", CV_WINDOW_AUTOSIZE);imshow(\"dst\", dImg);waitKey(0); 3&gt;.空间滤波：高斯滤波GaussianBlur()1234567891011121314151617181920212223-------------------Mat src = imread(\"E:/opencv_source/opencv_phsource/lena.jpg\", 1);cvtColor(src, src, COLOR_BGR2GRAY);//将图像转化为灰度图像namedWindow(\"src\", WINDOW_AUTOSIZE);//创建src的窗口，第二个参数表示自适应图片大小imshow(\"src\", src);//展示图片Mat dst = src.clone();//复制图片//函数直接调用GaussianBlur(src, dst, Size(7, 7), 80);/*参数注释输入原始图像，channels不限，各通道单独处理，depth应当是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F输出目标图像，与原始图像size和type一致；Size里参数为卷积核大小，必须是奇数；80为高斯分布里的sigmax,高斯核在x方向的标准差;高斯核在y方向的标准差（sigmaY=0时，其值自动由sigmaX确定（sigmaY=sigmaX）；sigmaY=sigmaX=0时，它们的值将由ksize.width和ksize.height自动确定）*/namedWindow(\"gassModel\", WINDOW_AUTOSIZE);imshow(\"gassModel\", dst);waitKey(0); 代码实现GaussianBlur()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253---------------------Mat src = imread(\"E:/opencv_source/opencv_phsource/lena.jpg\", 1);cvtColor(src, src, COLOR_BGR2GRAY);//将图像转化为灰度图像namedWindow(\"src\", WINDOW_AUTOSIZE);//创建src的窗口，第二个参数表示自适应图片大小imshow(\"src\", src);//展示图片//5*5卷积模板Mat model = Mat(5, 5, CV_64FC1);//CV_64FC1 64F代表每一个像素点元素占64位浮点数，通道数为1double sigma = 80;//超参数，经验所得//构建卷积核for (int i = -2; i &lt;= 2; i++)&#123; for (int j = -2; j &lt;= 2; j++) &#123; model.at&lt;double&gt;(i + 2, j + 2) = exp(-(i * i + j * j) / (2 * sigma * sigma)) /(2 * PI * sigma * sigma); //高斯分布函数 &#125;&#125;//构建卷积核后，要将该卷积核归一化处理，也就是将整个高斯卷积核中的值累加，并将卷积核中的每个值除以累加值。double gaussSum = 0;gaussSum = sum(model).val[0];//整个高斯卷积核中的值累加for (int i = 0; i &lt; model.rows; i++)&#123; for (int j = 0; j &lt; 5; j++) &#123; model.at&lt;double&gt;(i, j) = model.at&lt;double&gt;(i, j) / gaussSum; &#125;&#125;Mat dst = Mat(src.rows - 4, src.rows - 4, CV_8UC1);//5 * 5 卷积核遍历运算后，横纵列分别缺失4for (int i = 2; i &lt; src.rows - 2; i++)&#123; for (int j = 2; j &lt; src.cols - 2; j++) &#123; double sum = 0; for (int m = 0; m &lt; model.rows; m++) &#123; for (int n = 0; n &lt; model.cols; n++) &#123; sum += src.at&lt;uchar&gt;(i + m - 2, j + n - 2) * model.at&lt;double&gt;(m,n); &#125; &#125;//最里层2个for循环嵌套是利用卷积核进行运算，得到新的图像矩阵数据 dst.at&lt;uchar&gt;(i - 2, j - 2) = (uchar)sum;//进行赋值 &#125;&#125;namedWindow(\"gassModel\", WINDOW_AUTOSIZE);imshow(\"gassModel\", dst);waitKey(0); 结语：以上便是本次培训个人所得，第一次接触学习，难免有错误，敬请更公正！","categories":[],"tags":[]},{"title":"test_my_site","slug":"test-my-site","date":"2019-02-13T13:46:06.000Z","updated":"2019-02-13T13:46:06.109Z","comments":true,"path":"2019/02/13/test-my-site/","link":"","permalink":"http://yoursite.com/2019/02/13/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-02-13T13:40:16.594Z","updated":"2019-02-13T13:40:16.594Z","comments":true,"path":"2019/02/13/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}